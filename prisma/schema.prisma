generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

//
// ================= ENUMS =================
//

enum Role {
  ADMIN
  GRADE_TEACHER
  PARENT
}

enum Gender {
  MALE
  FEMALE
}

enum ExpenseStatus {
  PENDING
  APPROVED
  REJECTED
}

enum AttendanceStatus {
  PRESENT
  ABSENT
}

enum PaymentStatus {
  CRASH
  AYA
  KBZ
  WAVE
}

//
// ================= USER =================
// User = system login account only
// Student is NOT a User (important design decision)
//

model User {
  id        String   @id @default(uuid())
  name      String
  email     String   @unique
  password  String
  avatar    String?
  publicId  String?
  role      Role
  gender    Gender
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  parent       Parent?
  gradeTeacher GradeTeacher?
}

//
// ================= ACADEMIC =================
//

model AcademicYear {
  id        String   @id @default(uuid())
  name      String // eg: 2024â€“2025
  startDate DateTime
  endDate   DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  grades Grade[]
}

//
// Grade = class level inside an academic year
//

model Grade {
  id             String @id @default(uuid())
  name           String // eg: Grade 5
  academicYearId String

  academicYear    AcademicYear     @relation(fields: [academicYearId], references: [id])
  subjectTeachers SubjectTeacher[]
  students        GradeStudent[]
  teachers        GradeTeacher[]
  subjects        GradeSubject[]
  exams           Exam[]
}

//
// Many-to-Many: Student <-> Grade
//

model GradeStudent {
  id        String @id @default(uuid())
  studentId String
  gradeId   String

  student Student @relation(fields: [studentId], references: [id])
  grade   Grade   @relation(fields: [gradeId], references: [id])

  @@unique([studentId, gradeId])
}

//
// ================= STUDENT / PARENT =================
//
// Student does NOT have userId
// Student is created via Parent
//

model Student {
  id          String   @id @default(ulid())
  studentName String
  dateOfBirth DateTime
  gender      Gender
  avatar      String?
  publicId    String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  parents     StudentParent[]
  grades      GradeStudent[]
  attendance  Attendance[]
  examResults ExamResult[]
  balance     Balance?
  expenses    Expense[]
  topUps      BalanceTopUp[]
}

model Parent {
  id        String   @id @default(uuid())
  userId    String   @unique
  createdAt DateTime @default(now())

  user     User            @relation(fields: [userId], references: [id])
  students StudentParent[]
  expenses Expense[]
  topUps   BalanceTopUp[]
}

//
// Many-to-Many: Parent <-> Student
//

model StudentParent {
  id        String @id @default(uuid())
  studentId String
  parentId  String

  student Student @relation(fields: [studentId], references: [id])
  parent  Parent  @relation(fields: [parentId], references: [id])

  @@unique([studentId, parentId])
}

//
// ================= TEACHER =================
//
// GradeTeacher = homeroom / guide teacher
//

model GradeTeacher {
  id      String @id @default(uuid())
  userId  String @unique
  gradeId String

  user  User  @relation(fields: [userId], references: [id])
  grade Grade @relation(fields: [gradeId], references: [id])

  attendances Attendance[]
}

//
// Subject teacher profile (teaching info only)
// Avoid duplicate teacher sources
//

model TeacherProfile {
  id               String           @id @default(uuid())
  userId           String           @unique
  experience       String
  avatar           String?
  publicId         String?
  gradeAndSubjects SubjectTeacher[]
}

//
// ================= SUBJECT =================
//

model Subject {
  id   String @id @default(uuid())
  name String

  grades   GradeSubject[]
  teachers SubjectTeacher[]
  exams    Exam[]
}

//
// Many-to-Many: Grade <-> Subject
//

model GradeSubject {
  id        String @id @default(uuid())
  gradeId   String
  subjectId String

  grade   Grade   @relation(fields: [gradeId], references: [id])
  subject Subject @relation(fields: [subjectId], references: [id])

  @@unique([gradeId, subjectId])
}

//
// Many-to-Many: Subject <-> TeacherProfile
//

model SubjectTeacher {
  id        String         @id @default(uuid())
  subjectId String
  teacherId String
  gradeId   String
  subject   Subject        @relation(fields: [subjectId], references: [id])
  teacher   TeacherProfile @relation(fields: [teacherId], references: [id])
  grade     Grade          @relation(fields: [gradeId], references: [id])

  @@unique([subjectId, teacherId, gradeId])
}

//
// ================= ATTENDANCE =================
//

model Attendance {
  id             String           @id @default(uuid())
  studentId      String
  gradeTeacherId String
  date           DateTime
  status         AttendanceStatus
  note           String?

  student      Student      @relation(fields: [studentId], references: [id])
  gradeTeacher GradeTeacher @relation(fields: [gradeTeacherId], references: [id])
}

//
// ================= EXAM & RESULT =================
//
model Exam {
  id        String   @id @default(uuid())
  name      String
  subjectId String
  examDate  DateTime
  gradeId   String

  subject Subject      @relation(fields: [subjectId], references: [id])
  grade   Grade        @relation(fields: [gradeId], references: [id])
  results ExamResult[]
}

//
// ExamResult = single source of truth for marks
// SubjectMark model REMOVED (avoid redundancy)
//

model ExamResult {
  id        String @id @default(uuid())
  studentId String
  examId    String
  marks     Int

  student Student @relation(fields: [studentId], references: [id])
  exam    Exam    @relation(fields: [examId], references: [id])

  @@unique([studentId, examId])
}

//
// ================= FINANCE =================
//

//
// Balance = derived value (single row per student)
//

model Balance {
  id        String   @id @default(uuid())
  studentId String   @unique
  amount    Int      @default(0)
  updatedAt DateTime @updatedAt

  student Student @relation(fields: [studentId], references: [id])
}

//
// BalanceTopUp = transaction log (history)
//

model BalanceTopUp {
  id            String        @id @default(uuid())
  studentId     String
  parentId      String
  paymentMethod PaymentStatus
  amount        Int
  paymentRef    String?
  createdAt     DateTime      @default(now())

  student Student @relation(fields: [studentId], references: [id])
  parent  Parent  @relation(fields: [parentId], references: [id])
}

//
// Expense = spending request / deduction
//

model Expense {
  id          String        @id @default(uuid())
  studentId   String
  parentId    String
  description String?
  status      ExpenseStatus @default(PENDING)
  remark      String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  student Student @relation(fields: [studentId], references: [id])
  parent  Parent  @relation(fields: [parentId], references: [id])
}
